# 仪表盘“秒开”能力落地指南（Cache-first + SWR 持久化）

本文档总结本项目“秒开”能力的技术方案、已接入范围、以及后续新增接入时的测试先行（TDD）流程与注意事项。文档位于 `docs/` 目录，便于团队长期维护和扩展。

## 目标
- 刷新或首次进入页面时，优先显示上次可用数据（来自浏览器持久化缓存），做到“秒开”。
- 后台静默请求真实数据，返回后无闪烁地更新 UI。
- 对交互敏感的列表或仪表内容，显著降低“加载中/重试”体感。

## 核心思路
- 客户端：SWR + 自定义持久化 Provider（localStorage），按“缓存先展示、后台校验更新（SWR）”模式工作。
- 缓存策略：
  - 软 TTL：5 分钟（过期仍可渲染，但组件挂载会 revalidate）。
  - 硬 TTL：24 小时（超时则丢弃缓存，不参与首帧渲染）。
- 白名单（allowlist）：仅持久化明确允许的接口键，避免误持久化不适合缓存的数据。

## 代码结构
- Provider 实现：`lib/cache/swrPersist.ts`
  - `createPersistedSWRProvider` 返回一个 Map 兼容的 provider：
    - 读取：从 `localStorage.__swr_cache_v1__` 加载、按硬 TTL 过滤、恢复为 SWR state 结构（`{ data, ... }`）。
    - 写入：仅持久化每个 key 的 `data` 字段（减小体积，结构稳定）。
    - JSdom 兼容：不使用 Proxy 包裹 Map，改为覆写 set/delete/clear；测试环境下即时 flush，避免计时器抖动。
  - 可配置项：`storageKey`、`version`、`allowlist`、`softTtlMs`、`hardTtlMs`。
- 全局装配：`app/providers.tsx`
  - 通过 `<SWRConfig provider={createPersistedSWRProvider({...})} ...>` 注入。
  - 已配置 allowlist：
    - `/api/referrals/summary`
    - `/api/referrals/invites`
    - `/api/packages/credits`
    - `/api/packages`
    - `/api/apikeys`
    - `/api/dashboard`（含子路由）

## 已接入“秒开”的模块与接口
- 推荐页（邀请）：`components/dashboard/ReferralContent.tsx`
  - 接口：`/api/referrals/summary`、`/api/referrals/invites`
- 购买积分（独立积分）：`components/dashboard/IndependentPackages.tsx`
  - 接口：`/api/packages/credits`
- 订阅套餐：`components/dashboard/PlansContent.tsx`
  - 接口：`/api/packages`
- API Keys：`components/dashboard/ApiKeysContent.tsx`
  - 接口：`/api/apikeys`
- 积分明细（Credits Details）：`components/dashboard/TeamMembers.tsx`
  - 接口：`/api/dashboard/model-usage`
- 消费趋势（Consumption Trends 图表）：`components/dashboard/WorkSummaryChart.tsx`
  - 接口：`/api/dashboard/consumption-trends`

## 新增接入的 TDD 流程（测试先行）
> 任何新增“秒开”改造，请先补测试再实现业务，测试通过后合并。

1) 编写组件侧缓存测试（示例命名：`tests/components/<Name>.cache-persist.test.tsx`）
- 预置缓存：
  - 写入 `localStorage.__swr_cache_v1__`，结构示例：
    ```json
    {
      "v": "v1",
      "items": [
        { "k": "/api/xxx", "t": 1710000000000, "v": { "data": { /* 缓存数据 */ } } }
      ]
    }
    ```
- 渲染被测组件时，用 `SWRConfig` 包裹并传入 `createPersistedSWRProvider({ storageKey: '__swr_cache_v1__' })`。
- Mock `fetch`：先返回缓存对应的“新数据”用于后台更新，断言“先看到缓存内容 → 再更新成新内容”。
- 第三方库兼容：如 ECharts 需要 `jest.mock('echarts', ...)` 并提供 `graphic.LinearGradient` 的虚拟实现。

2) 组件改造（useEffect + fetch → useSWR）
- 改为：`const { data } = useSWR(key, fetcher)`，`const loading = !data`。
- 列表/卡片：首帧展示 `data`，避免“全局骨架”；仅在 `!data` 且无缓存时渲染轻量 Loading。
- 变更/创建/删除后：调用 `mutate(key)` 刷新最新数据。

3) 持久化白名单处理
- 如需持久化该接口数据，确认是否加入 allowlist。
- 若数据包含敏感字段，请评估（字段裁剪或不持久化）。

4) 手工回归
- DevTools Network 开启 `Slow 3G` 节流，刷新页面：组件应“秒出”缓存，随后静默更新。
- `Application -> Local Storage` 可检查 `__swr_cache_v1__` 内容和时间戳。

## 示例测试片段（组件）
```tsx
/** @jest-environment jsdom */
import React from 'react'
import { render, screen, waitFor } from '@testing-library/react'
import { SWRConfig } from 'swr'
import MyComp from '@/components/MyComp'
import { createPersistedSWRProvider } from '@/lib/cache/swrPersist'

const storageKey = '__swr_cache_v1__'
const key = '/api/my/data'

beforeEach(() => {
  const now = Date.now()
  const blob = { v: 'v1', items: [ { k: key, t: now-30000, v: { data: { title: 'CACHED' } } } ] }
  localStorage.setItem(storageKey, JSON.stringify(blob))
  ;(global as any).fetch = jest.fn(async (url: string) => {
    if (url === key) return { ok: true, json: async () => ({ title: 'FRESH' }) } as any
    throw new Error('unexpected')
  })
})

afterEach(() => { localStorage.clear(); (global as any).fetch = undefined })

test('cache first then fresh', async () => {
  render(
    <SWRConfig value={{ provider: createPersistedSWRProvider({ storageKey }) }}>
      <MyComp />
    </SWRConfig>
  )
  expect(await screen.findByText('CACHED')).toBeInTheDocument()
  await waitFor(() => expect(screen.getByText('FRESH')).toBeInTheDocument())
})
```

## 手工验证清单
- 刷新页面首帧应“秒开”。
- 慢网下无明显闪烁，数据就地更新。
- 关闭/打开卡片或切换页签时，命中过去 5 分钟内缓存应仍然“秒出”。

## 常见问题与排查
- JSdom 报错：“Method Map.prototype.get called on incompatible receiver”
  - 原因：Map 被 Proxy 包裹导致 this 绑定不兼容；现已改为覆写 Map 方法避免此问题。
- ECharts 在测试环境报 `graphic.LinearGradient` undefined
  - 用 `jest.mock('echarts', () => ({ init:..., graphic: { LinearGradient: () => ({}) } }))` 处理。
- 真实接口 `force-dynamic` + `no-store` 不影响客户端缓存
  - 客户端缓存只在浏览器侧，SSR 不依赖；允许更保守的服务端缓存头。

## 回滚与开关
- 可以通过修改 `app/providers.tsx` 关闭某些 allowlist 键，或临时移除 provider。
- 升级缓存结构时提高 `version`，旧缓存将被忽略；必要时指导用户清空本地存储。

## 维护建议
- 新增/修改“秒开”接入均遵循本文 TDD 流程。
- 对列表/图表优先改造，收益最明显；操作型页面（创建/删除）注意配合 `mutate`。
- 定期回顾 allowlist，确认未引入敏感数据的长时持久化。

更多背景与配置细节可参考：`docs/persisted-cache.md`。
